# Code Audit Implementation Plan

## Executive Summary

**Overall Health:** ðŸŸ¡ **Moderate/Good (B+)**

The MilkStack Multi-Agent Hub has successfully transitioned to "Agency V2," featuring a robust state-machine-driven architecture (`WorkflowEngine`) and local-first persistence via IndexedDB. The separation of orchestration logic from the UI is a significant strength.

However, the application faces immediate scalability and reliability risks. The primary bottlenecks are the monolithic `App.tsx` (acting as a "God Component"), extrinsic rate limiting that leaves API calls vulnerable, and a lack of centralized configuration. Addressing these issues is crucial to prevent regression and ensure stability as the application grows.

**Total Issues Identified:** 12
**Breakdown by Severity:**
*   ðŸ”´ **Critical:** 2
*   ðŸŸ  **High:** 3
*   ðŸŸ¡ **Medium:** 4
*   ðŸ”µ **Low:** 3

**Overall Security Posture:** Moderate. While local-first storage reduces server-side risks, the application lacks strict input validation (Zod) for agent outputs and relies on client-side rate limiting that is easily bypassed.

---

## Implementation Roadmap

### ðŸ”´ Critical Issues (Immediate Action Required)

#### 1. Issue: Unreliable Rate Limiting Architecture
**Description:** The `RateLimiter` is currently applied at the consumer level (in `geminiService.ts`) rather than the service level (`AgentExecutor.ts`). This allows developers to bypass limits by calling the executor directly, leading to potential API bans or 429 errors.
**Impact:** High risk of application instability and API quota exhaustion.
**Location:** `src/services/AgentExecutor.ts`, `src/services/geminiService.ts`

**Step-by-Step Implementation:**
1.  **Modify AgentExecutor:** Update the `AgentExecutor` class to accept a `RateLimiter` instance in its constructor.
2.  **Internalize Execution:** Move the `rateLimiter.execute()` wrapper logic inside `AgentExecutor.executeStreaming` and `executeNonStreaming`.
3.  **Refactor Consumers:** Update `geminiService.ts` and `messageEnhancementService.ts` to pass the rate limiter instance during instantiation, rather than wrapping calls manually.
4.  **Verification:** Attempt to trigger rapid-fire requests; ensure the `RateLimiter` queue logic engages automatically.

**Code Example:**
```typescript
// src/services/AgentExecutor.ts
export class AgentExecutor {
  constructor(
    private model: GenerativeModel,
    private rateLimiter: RateLimiter // Injected dependency
  ) {}

  async executeNonStreaming(prompt: string): Promise<GenerateContentResult> {
    return this.rateLimiter.execute(async () => {
      return await this.model.generateContent(prompt);
    });
  }
}
```
**Estimated Effort:** 2 Hours
**Dependencies:** None
**Testing Requirements:** Unit test `AgentExecutor` with a mock rate limiter to ensure calls are queued.

#### 2. Issue: Decentralized and Hardcoded Configuration
**Description:** Critical configuration values, specifically model identifiers (`gemini-2.5-pro`), are hardcoded as strings across 5+ different files.
**Impact:** Updating the model version requires a global find-and-replace, which is error-prone and may lead to version mismatches.
**Location:** `src/services/`, `src/config/` (to be created)

**Step-by-Step Implementation:**
1.  **Create Config File:** Create `src/config/ai.ts` (or `constants.ts`).
2.  **Define Constants:** Export `DEFAULT_MODEL`, `FALLBACK_MODEL`, and `SAFETY_SETTINGS`.
3.  **Refactor Services:** Replace all hardcoded strings in `AgentExecutor.ts`, `geminiService.ts`, `taskParser.ts`, and `rustyPortableService.ts` with these constants.
4.  **Verification:** Change the constant value in one place and verify the application uses the new model ID in network requests.

**Estimated Effort:** 1 Hour
**Dependencies:** None
**Testing Requirements:** Manual verification of API request payloads.

---

### ðŸŸ  High Priority Issues

#### 3. Issue: Monolithic `App.tsx` (God Component)
**Description:** `App.tsx` is ~800 lines long and violates the Single Responsibility Principle by handling routing, global state, keyboard shortcuts, and UI orchestration.
**Impact:** High cognitive load, difficult maintenance, and high risk of regression during updates.
**Location:** `src/App.tsx`

**Step-by-Step Implementation:**
1.  **Extract Hooks:** Move logic into custom hooks:
    *   `src/hooks/useKeyboardShortcuts.ts` (Global shortcuts)
    *   `src/hooks/useWorkflowManager.ts` (Workflow state logic)
    *   `src/hooks/useRustyBridge.ts` (Rusty agent integration)
2.  **Simplify Component:** Refactor `App.tsx` to call these hooks, reducing the file size and complexity.
3.  **Verification:** Ensure all keyboard shortcuts and workflow transitions function exactly as before.

**Estimated Effort:** 6 Hours
**Dependencies:** Issue #4 (Context API) is highly recommended before this to avoid prop-drilling hell.
**Testing Requirements:** Regression testing of all UI interactions.

#### 4. Issue: Lack of Global State Management (Prop Drilling)
**Description:** Data flows strictly parent-to-child through 4-5 levels (e.g., `App` -> `Sidebar` -> `ProjectSelector`).
**Impact:** Rigid component tree; adding a new feature requires modifying every component in the hierarchy.
**Location:** `src/context/` (to be created), `src/App.tsx`

**Step-by-Step Implementation:**
1.  **Create Contexts:**
    *   `src/context/ProjectContext.tsx`: Manage `projects`, `activeProjectId`, `createProject`, `deleteProject`.
    *   `src/context/SettingsContext.tsx`: Manage global application settings.
2.  **Wrap App:** Wrap the application root with these providers.
3.  **Consume Context:** Update `Sidebar`, `ChatView`, and `ProjectSelector` to use `useContext` instead of receiving props.
4.  **Verification:** Verify project switching and creation still works without props being passed.

**Estimated Effort:** 4 Hours
**Dependencies:** None
**Testing Requirements:** Verify component re-renders are minimized.

#### 5. Issue: Security - Input and URL Sanitization
**Description:** The app lacks strict sanitization for Markdown rendering (potential XSS via `javascript:` links) and relies on loose heuristics for context pruning.
**Impact:** Security vulnerabilities and potential context window overflows.
**Location:** `src/components/MessageBubble.tsx`, `src/services/geminiService.ts`

**Step-by-Step Implementation:**
1.  **Sanitize Markdown:** Configure `ReactMarkdown` in `MessageBubble.tsx` to strictly disallow `javascript:` or `data:` protocols in links.
2.  **Externalize Blocklist:** Move `ORCHESTRATOR_CONTEXT_BLOCKLIST` from `geminiService.ts` to a config file.
3.  **Verification:** Attempt to inject a malicious link in a chat message; ensure it does not execute.

**Estimated Effort:** 2 Hours
**Dependencies:** None
**Testing Requirements:** Security unit tests for the markdown renderer.

---

### ðŸŸ¡ Medium Priority Issues

#### 6. Issue: Weak Type Safety in Agent Executor
**Description:** `AgentExecutor.ts` uses `any` types for Google GenAI SDK responses (`result.stream || result`), bypassing TypeScript protections.
**Impact:** SDK updates could silently break the application at runtime.
**Location:** `src/services/AgentExecutor.ts`

**Step-by-Step Implementation:**
1.  **Define Interfaces:** Create proper interfaces for the GenAI response objects based on the SDK documentation.
2.  **Remove Any:** Replace `any` with the specific types (e.g., `GenerateContentResult`).
3.  **Type Guards:** Implement runtime checks to distinguish between streaming and non-streaming responses safely.

**Estimated Effort:** 2 Hours
**Dependencies:** None
**Testing Requirements:** TypeScript compilation check.

#### 7. Issue: Lack of Runtime Validation (Zod)
**Description:** The app manually parses JSON from agents in `taskParser.ts`, which is brittle.
**Impact:** Malformed agent responses can crash the workflow or produce unpredictable states.
**Location:** `src/services/taskParser.ts`

**Step-by-Step Implementation:**
1.  **Define Schemas:** Create Zod schemas for `TaskMap`, `AgentResponse`, and `Plan`.
2.  **Implement Validation:** Replace manual parsing logic with `Schema.parse()` or `Schema.safeParse()`.
3.  **Error Handling:** Return structured validation errors to the LLM so it can self-correct.

**Estimated Effort:** 3 Hours
**Dependencies:** None
**Testing Requirements:** Unit tests with malformed JSON inputs.

#### 8. Issue: Missing Error Boundaries
**Description:** A crash in a UI component (e.g., markdown parsing error) will cause the entire screen to go white.
**Impact:** Poor user experience and data loss if the app crashes before saving.
**Location:** `src/components/`

**Step-by-Step Implementation:**
1.  **Create Component:** Create `src/components/ErrorBoundary.tsx`.
2.  **Wrap Critical Areas:** Wrap `ChatView` and `Sidebar` with the Error Boundary.
3.  **Fallback UI:** Design a "Something went wrong" fallback that allows the user to reload or export their data.

**Estimated Effort:** 2 Hours
**Dependencies:** None
**Testing Requirements:** Manually throw an error in a component to verify the boundary catches it.

#### 9. Issue: Rusty Meta-Agent Duplication
**Description:** `RustyChatModal` duplicates logic and UI components from the main `ChatView`.
**Impact:** Inconsistent UI and double maintenance effort.
**Location:** `src/components/RustyChatModal.tsx`

**Step-by-Step Implementation:**
1.  **Refactor Modal:** Update `RustyChatModal` to reuse `MessageList` and `MessageInput` components.
2.  **Standardize State:** Ensure the message format used by Rusty matches the main chat types.

**Estimated Effort:** 3 Hours
**Dependencies:** None
**Testing Requirements:** Verify syntax highlighting and message rendering in Rusty modal.

---

### ðŸ”µ Low Priority Issues

#### 10. Issue: Bloated `types.ts`
**Description:** `src/types.ts` contains definitions for everything (Agents, GitHub, Settings, etc.).
**Impact:** Hard to navigate and maintain.
**Location:** `src/types.ts`

**Step-by-Step Implementation:**
1.  **Split Files:** Create `src/types/` directory.
2.  **Migrate:** Move types into `agent.ts`, `project.ts`, `workflow.ts`, etc.
3.  **Update Imports:** Update all import paths across the application.

**Estimated Effort:** 1 Hour
**Dependencies:** None

#### 11. Issue: GitHub Service Robustness
**Description:** `githubService.ts` lacks specific error handling for rate limits and uses raw `fetch`.
**Impact:** GitHub operations may fail silently or without clear user feedback.
**Location:** `src/services/githubService.ts`

**Step-by-Step Implementation:**
1.  **Typed Responses:** Add return types to API calls.
2.  **Error Handling:** Check for `403` (Rate Limit) and `401` (Auth) specifically and throw typed errors.

**Estimated Effort:** 2 Hours
**Dependencies:** None

#### 12. Issue: Legacy Code Cleanup
**Description:** `codebaseProcessor.ts` contains hardcoded ignore lists; `App.tsx` has commented-out zombie code.
**Impact:** Technical debt.
**Location:** Various

**Step-by-Step Implementation:**
1.  **Remove Dead Code:** Delete commented-out blocks in `App.tsx`.
2.  **Config:** Move ignore lists to the new `src/config/constants.ts`.

**Estimated Effort:** 1 Hour
**Dependencies:** Issue #2 (Configuration)
