The Initial Specification describes a dynamic, conversational simulation of a human software team ("The Living Team"), emphasizing real-time handoffs, visual agent presence, and a hierarchical chain of command (Orchestrator > Product Planner > Orchestrator > Specialist > Orchestrator > etc). The Current Specification has evolved into a deterministic "Agency V2" state machine, prioritizing structured TaskMaps, parallel execution, and engineering robustness (IndexedDB, Diff Views).

While the Current Specification is technically more robust regarding state management and debugging (via "Rusty"), it has discarded significant User Experience and Strategic Workflow elements that gave the application its unique "Multi-Agent" character.

Restore the "Living Team" UX (High Impact / Low Risk)
Action: Implement the Active Staff Roster in the sidebar.
Logic: Even if the backend uses a TaskMap, the UI should visualize which agent is currently executing a step in that map.
Dependency: Requires mapping the Current Spec's WorkflowEngine states to specific Agent IDs.

Distinct "Thinking" States (The Handoff)
Description: Explicit UI updates telling the user exactly who is working.
Initial Spec Detail: "Orchestrator Phase: 'Orchestrator is thinking...' -> Handoff: 'Architect is typing...'"
Current Status: The Current spec mentions a "Queue UI" and "Countdown," but not the persona-specific activity indicators.
Importance: Builds trust. The user understands why a response is taking time because they see the "Architect" is busy.

The "Active Staff Roster" & Visual Feedback
Description: A persistent sidebar UI showing the status of all 16 agents.
Initial Spec Detail: "Active Staff Roster: A live list of all agents... Agents light up/animate when they are 'thinking' or 'speaking.' Status Indicators: Idle (Grey), Active (Color)."
Current Status: Missing. The current UI focuses on the Chat Stream and Diff Views.
Importance: This is the defining UX feature of "MilkStack." It visualizes the team. Without it, the app feels like a standard chatbot rather than a multi-agent hub.
Complexity: Medium (Requires real-time state management linked to UI components)

## Current State

**What you have:**
- `AgentList`/`AgentListItem` in sidebar (shows agents)
- `AgentStatus` enum (only `Idle`/`Active`)
- `WorkflowEngine.getCurrentStage()` (returns current stage with `agents[]`)
- `TypingIndicator` (shows one agent thinking)
- `activeAgentId` tracking (single agent)

**What's missing:**
1. Enhanced `AgentStatus` enum — needs `Thinking` and `Speaking`
2. Multi-agent status tracking — parallel stages need multiple active agents
3. WorkflowEngine → Agent ID mapping — map stage execution to agent statuses
4. Real-time status updates — propagate status changes to the UI

## Implementation Plan

---

## **Step 1: Recreate the deleted files**

### File 1: `src/services/agentStatusManager.ts`

```typescript
/**
 * AgentStatusManager
 * 
 * Centralized manager for tracking real-time agent status across the application.
 * Used to power the "Living Team" UX - showing which agents are thinking, speaking, or idle.
 */

import { AgentStatus } from '../types/agent';

export type AgentStatusChangeCallback = (agentId: string, status: AgentStatus) => void;

export class AgentStatusManager {
  private statuses: Map<string, AgentStatus> = new Map();
  private listeners: Set<AgentStatusChangeCallback> = new Set();

  /**
   * Set status for a specific agent
   */
  setStatus(agentId: string, status: AgentStatus): void {
    const previousStatus = this.statuses.get(agentId);
    this.statuses.set(agentId, status);
    
    // Notify listeners if status changed
    if (previousStatus !== status) {
      this.notifyListeners(agentId, status);
    }
  }

  /**
   * Get current status for an agent (defaults to Idle)
   */
  getStatus(agentId: string): AgentStatus {
    return this.statuses.get(agentId) || AgentStatus.Idle;
  }

  /**
   * Get all current statuses (immutable copy)
   */
  getAllStatuses(): ReadonlyMap<string, AgentStatus> {
    return new Map(this.statuses);
  }

  /**
   * Clear status for an agent (sets to Idle)
   */
  clearStatus(agentId: string): void {
    this.statuses.delete(agentId);
    this.notifyListeners(agentId, AgentStatus.Idle);
  }

  /**
   * Clear all statuses (sets all to Idle)
   */
  clearAll(): void {
    const agentIds = Array.from(this.statuses.keys());
    this.statuses.clear();
    agentIds.forEach(id => this.notifyListeners(id, AgentStatus.Idle));
  }

  /**
   * Subscribe to status changes
   */
  subscribe(callback: AgentStatusChangeCallback): () => void {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }

  /**
   * Notify all listeners of a status change
   */
  private notifyListeners(agentId: string, status: AgentStatus): void {
    this.listeners.forEach(callback => {
      try {
        callback(agentId, status);
      } catch (error) {
        console.error('Error in agent status listener:', error);
      }
    });
  }
}

// Singleton instance
export const agentStatusManager = new AgentStatusManager();
```

### File 2: `src/hooks/useAgentStatus.ts`

```typescript
/**
 * useAgentStatus Hook
 * 
 * React hook for accessing real-time agent status in components.
 * Automatically subscribes/unsubscribes to status changes.
 */

import { useState, useEffect } from 'react';
import { AgentStatus } from '../types/agent';
import { agentStatusManager } from '../services/agentStatusManager';

export function useAgentStatus(agentId: string): AgentStatus {
  const [status, setStatus] = useState<AgentStatus>(() => 
    agentStatusManager.getStatus(agentId)
  );

  useEffect(() => {
    const unsubscribe = agentStatusManager.subscribe((id, newStatus) => {
      if (id === agentId) {
        setStatus(newStatus);
      }
    });

    // Update immediately in case status changed before subscription
    setStatus(agentStatusManager.getStatus(agentId));

    return unsubscribe;
  }, [agentId]);

  return status;
}

/**
 * useAllAgentStatuses Hook
 * 
 * Returns a map of all agent statuses, updating in real-time.
 */
export function useAllAgentStatuses(): ReadonlyMap<string, AgentStatus> {
  const [statuses, setStatuses] = useState<ReadonlyMap<string, AgentStatus>>(() =>
    agentStatusManager.getAllStatuses()
  );

  useEffect(() => {
    const unsubscribe = agentStatusManager.subscribe(() => {
      setStatuses(agentStatusManager.getAllStatuses());
    });

    // Update immediately
    setStatuses(agentStatusManager.getAllStatuses());

    return unsubscribe;
  }, []);

  return statuses;
}
```

## Step 2: Update `src/types/agent.ts`

Add the new statuses to the enum:

```typescript:src/types/agent.ts
export enum AgentStatus {
  Idle = 'idle',
  Thinking = 'thinking',    // NEW: Agent is processing/analyzing
  Speaking = 'speaking',   // NEW: Agent is streaming response
  Active = 'active',        // Legacy: kept for backward compatibility
}
```

## Step 3: Integration into `geminiService.ts`

Add the import at the top of the file (around line 12):

```typescript
import { agentStatusManager } from './agentStatusManager';
import { AgentStatus } from '../types/agent';
```

### Integration Point 1: Product Planner execution (Sequential)

Location: Around line 368-409 in `executeAgencyV2Workflow`

```typescript
// BEFORE (line 369):
onAgentChange(productPlanner.id);

// AFTER:
onAgentChange(productPlanner.id);
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Thinking);

// ... existing code ...

// BEFORE (line 373):
let plannerResponse = '';

// Rate limiting now handled internally by AgentExecutor
await executor.executeStreaming(
    productPlanner,
    DEFAULT_MODEL,
    conversationContents,
    {
        systemInstruction: productPlanner.prompt,
        safetySettings: SAFETY_SETTINGS,
    },
    (chunk) => {
        onMessageUpdate(chunk);
        plannerResponse += chunk;
    }
);

// AFTER (update the callback to set Speaking status):
let plannerResponse = '';
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Speaking); // Set to Speaking when streaming starts

// Rate limiting now handled internally by AgentExecutor
await executor.executeStreaming(
    productPlanner,
    DEFAULT_MODEL,
    conversationContents,
    {
        systemInstruction: productPlanner.prompt,
        safetySettings: SAFETY_SETTINGS,
    },
    (chunk) => {
        onMessageUpdate(chunk);
        plannerResponse += chunk;
    }
);

// AFTER streaming completes (around line 395, after onNewMessage):
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);

// BEFORE (line 407):
onAgentChange(null);
return { updatedTaskState: null };

// AFTER:
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);
onAgentChange(null);
return { updatedTaskState: null };

// BEFORE (line 414):
onAgentChange(null);
return { updatedTaskState: null };

// AFTER:
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);
onAgentChange(null);
return { updatedTaskState: null };
```

### Integration Point 2: Sequential stage execution

Location: Around line 519-560

```typescript
// BEFORE (line 520):
onAgentChange(stageAgent.id);

let agentResponse = '';

// Rate limiting now handled internally by AgentExecutor
await executor.executeStreaming(
    stageAgent,
    currentStage.agents[0].model,
    conversationContents,
    streamConfig,
    (chunk) => {
        onMessageUpdate(chunk);
        agentResponse += chunk;
    }
);

// AFTER:
onAgentChange(stageAgent.id);
agentStatusManager.setStatus(stageAgent.id, AgentStatus.Thinking);

let agentResponse = '';
let isFirstChunk = true;

// Rate limiting now handled internally by AgentExecutor
await executor.executeStreaming(
    stageAgent,
    currentStage.agents[0].model,
    conversationContents,
    streamConfig,
    (chunk) => {
        // Set to Speaking on first chunk
        if (isFirstChunk) {
            agentStatusManager.setStatus(stageAgent.id, AgentStatus.Speaking);
            isFirstChunk = false;
        }
        onMessageUpdate(chunk);
        agentResponse += chunk;
    }
);

// AFTER streaming completes (around line 546, after onNewMessage):
agentStatusManager.setStatus(stageAgent.id, AgentStatus.Idle);

// BEFORE (line 554 - in catch block):
} catch (error: any) {
    console.error(`[Agency V2] Stage execution failed:`, error);
    engine.recordFailure(error.message);
    const errorMsg = createSystemMessage(`**❌ Stage Failed**: ${error.message}`, true);
    onNewMessage(errorMsg);
    return { updatedTaskState: engine.getState() };
}

// AFTER:
} catch (error: any) {
    console.error(`[Agency V2] Stage execution failed:`, error);
    agentStatusManager.setStatus(stageAgent.id, AgentStatus.Idle); // Clear status on error
    engine.recordFailure(error.message);
    const errorMsg = createSystemMessage(`**❌ Stage Failed**: ${error.message}`, true);
    onNewMessage(errorMsg);
    return { updatedTaskState: engine.getState() };
}
```

### Integration Point 3: Parallel stage execution

Location: Around line 638-670

```typescript
// BEFORE (line 638):
const parallelPromises = stageAgents.map(async (agent, index) => {
    const stageAgentDef = currentStage.agents[index];

    // Rate limiting now handled internally by AgentExecutor
    try {
        const result = await executor.executeNonStreaming(
            agent,
            stageAgentDef.model,
            conversationContents,
            agentConfig
        );

        return {
            agent,
            content: result.content,
            model: result.model
        };
    } catch (error: any) {
        console.error(`[Agency V2] Parallel agent ${agent.name} failed:`, error);
        return {
            agent,
            content: `Error: ${error.message}`,
            model: stageAgentDef.model
        };
    }
});

// AFTER:
// Set all parallel agents to Thinking before starting
stageAgents.forEach(agent => {
    agentStatusManager.setStatus(agent.id, AgentStatus.Thinking);
    onAgentChange(agent.id); // Update active agent (will show last one, but status manager tracks all)
});

const parallelPromises = stageAgents.map(async (agent, index) => {
    const stageAgentDef = currentStage.agents[index];

    // Rate limiting now handled internally by AgentExecutor
    try {
        // Set to Speaking when execution starts (non-streaming, so it's quick)
        agentStatusManager.setStatus(agent.id, AgentStatus.Speaking);
        
        const result = await executor.executeNonStreaming(
            agent,
            stageAgentDef.model,
            conversationContents,
            agentConfig
        );

        // Set to Idle when complete
        agentStatusManager.setStatus(agent.id, AgentStatus.Idle);

        return {
            agent,
            content: result.content,
            model: result.model
        };
    } catch (error: any) {
        console.error(`[Agency V2] Parallel agent ${agent.name} failed:`, error);
        agentStatusManager.setStatus(agent.id, AgentStatus.Idle); // Clear on error
        return {
            agent,
            content: `Error: ${error.message}`,
            model: stageAgentDef.model
        };
    }
});
```

### Integration Point 4: Workflow completion points

Location: Lines 753, 761, 766

```typescript
// BEFORE (line 753):
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// AFTER:
agentStatusManager.clearAll(); // Clear all agent statuses when workflow completes
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// BEFORE (line 761):
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// AFTER:
agentStatusManager.clearAll();
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// BEFORE (line 766):
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// AFTER:
agentStatusManager.clearAll();
onAgentChange(null);
return { updatedTaskState: engine.getState() };
```

### Integration Point 5: Orchestrator routing (optional)

If you want to show Orchestrator status during routing, find where `getAgentResponse` calls the orchestrator and add:

```typescript
// When Orchestrator is called (find the orchestrator execution point):
const orchestrator = AGENT_PROFILES.find(a => a.id === 'agent-orchestrator-001');
if (orchestrator) {
    agentStatusManager.setStatus(orchestrator.id, AgentStatus.Thinking);
}

// After orchestrator completes:
if (orchestrator) {
    agentStatusManager.setStatus(orchestrator.id, AgentStatus.Idle);
}
```

## Step 4: Update components

Update `AgentListItem.tsx` and `TypingIndicator.tsx` as shown in the earlier draft.

## Summary of changes

1. Import `agentStatusManager` and `AgentStatus` at the top of `geminiService.ts`
2. Set `Thinking` when an agent starts processing
3. Set `Speaking` when streaming begins (first chunk)
4. Set `Idle` when an agent completes or errors
5. Clear all statuses when the workflow completes

This adds real-time status tracking without changing the backend logic. The UI will show which agents are active at any time.

Want me to create a checklist or test plan for verifying the integration?

```typescript
/**
 * AgentStatusManager
 * 
 * Centralized manager for tracking real-time agent status across the application.
 * Used to power the "Living Team" UX - showing which agents are thinking, speaking, or idle.
 */

import { AgentStatus } from '../types/agent';

export type AgentStatusChangeCallback = (agentId: string, status: AgentStatus) => void;

export class AgentStatusManager {
  private statuses: Map<string, AgentStatus> = new Map();
  private listeners: Set<AgentStatusChangeCallback> = new Set();

  /**
   * Set status for a specific agent
   */
  setStatus(agentId: string, status: AgentStatus): void {
    const previousStatus = this.statuses.get(agentId);
    this.statuses.set(agentId, status);
    
    // Notify listeners if status changed
    if (previousStatus !== status) {
      this.notifyListeners(agentId, status);
    }
  }

  /**
   * Get current status for an agent (defaults to Idle)
   */
  getStatus(agentId: string): AgentStatus {
    return this.statuses.get(agentId) || AgentStatus.Idle;
  }

  /**
   * Get all current statuses (immutable copy)
   */
  getAllStatuses(): ReadonlyMap<string, AgentStatus> {
    return new Map(this.statuses);
  }

  /**
   * Clear status for an agent (sets to Idle)
   */
  clearStatus(agentId: string): void {
    this.statuses.delete(agentId);
    this.notifyListeners(agentId, AgentStatus.Idle);
  }

  /**
   * Clear all statuses (sets all to Idle)
   */
  clearAll(): void {
    const agentIds = Array.from(this.statuses.keys());
    this.statuses.clear();
    agentIds.forEach(id => this.notifyListeners(id, AgentStatus.Idle));
  }

  /**
   * Subscribe to status changes
   */
  subscribe(callback: AgentStatusChangeCallback): () => void {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }

  /**
   * Notify all listeners of a status change
   */
  private notifyListeners(agentId: string, status: AgentStatus): void {
    this.listeners.forEach(callback => {
      try {
        callback(agentId, status);
      } catch (error) {
        console.error('Error in agent status listener:', error);
      }
    });
  }
}

// Singleton instance
export const agentStatusManager = new AgentStatusManager();
```

```typescript
/**
 * useAgentStatus Hook
 * 
 * React hook for accessing real-time agent status in components.
 * Automatically subscribes/unsubscribes to status changes.
 */

import { useState, useEffect } from 'react';
import { AgentStatus } from '../types/agent';
import { agentStatusManager } from '../services/agentStatusManager';

export function useAgentStatus(agentId: string): AgentStatus {
  const [status, setStatus] = useState<AgentStatus>(() => 
    agentStatusManager.getStatus(agentId)
  );

  useEffect(() => {
    const unsubscribe = agentStatusManager.subscribe((id, newStatus) => {
      if (id === agentId) {
        setStatus(newStatus);
      }
    });

    // Update immediately in case status changed before subscription
    setStatus(agentStatusManager.getStatus(agentId));

    return unsubscribe;
  }, [agentId]);

  return status;
}

/**
 * useAllAgentStatuses Hook
 * 
 * Returns a map of all agent statuses, updating in real-time.
 */
export function useAllAgentStatuses(): ReadonlyMap<string, AgentStatus> {
  const [statuses, setStatuses] = useState<ReadonlyMap<string, AgentStatus>>(() =>
    agentStatusManager.getAllStatuses()
  );

  useEffect(() => {
    const unsubscribe = agentStatusManager.subscribe(() => {
      setStatuses(agentStatusManager.getAllStatuses());
    });

    // Update immediately
    setStatuses(agentStatusManager.getAllStatuses());

    return unsubscribe;
  }, []);

  return statuses;
}
```

```typescript
export enum AgentStatus {
  Idle = 'idle',
  Thinking = 'thinking',    // NEW: Agent is processing/analyzing
  Speaking = 'speaking',   // NEW: Agent is streaming response
  Active = 'active',        // Legacy: kept for backward compatibility
}
```

```typescript
import { agentStatusManager } from './agentStatusManager';
import { AgentStatus } from '../types/agent';
```

```typescript
// BEFORE (line 369):
onAgentChange(productPlanner.id);

// AFTER:
onAgentChange(productPlanner.id);
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Thinking);

// ... existing code ...

// BEFORE (line 373):
let plannerResponse = '';

// Rate limiting now handled internally by AgentExecutor
await executor.executeStreaming(
    productPlanner,
    DEFAULT_MODEL,
    conversationContents,
    {
        systemInstruction: productPlanner.prompt,
        safetySettings: SAFETY_SETTINGS,
    },
    (chunk) => {
        onMessageUpdate(chunk);
        plannerResponse += chunk;
    }
);

// AFTER (update the callback to set Speaking status):
let plannerResponse = '';
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Speaking); // Set to Speaking when streaming starts

// Rate limiting now handled internally by AgentExecutor
await executor.executeStreaming(
    productPlanner,
    DEFAULT_MODEL,
    conversationContents,
    {
        systemInstruction: productPlanner.prompt,
        safetySettings: SAFETY_SETTINGS,
    },
    (chunk) => {
        onMessageUpdate(chunk);
        plannerResponse += chunk;
    }
);

// AFTER streaming completes (around line 395, after onNewMessage):
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);

// BEFORE (line 407):
onAgentChange(null);
return { updatedTaskState: null };

// AFTER:
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);
onAgentChange(null);
return { updatedTaskState: null };

// BEFORE (line 414):
onAgentChange(null);
return { updatedTaskState: null };

// AFTER:
agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);
onAgentChange(null);
return { updatedTaskState: null };
```

```typescript
// BEFORE (line 520):
onAgentChange(stageAgent.id);

let agentResponse = '';

// Rate limiting now handled internally by AgentExecutor
await executor.executeStreaming(
    stageAgent,
    currentStage.agents[0].model,
    conversationContents,
    streamConfig,
    (chunk) => {
        onMessageUpdate(chunk);
        agentResponse += chunk;
    }
);

// AFTER:
onAgentChange(stageAgent.id);
agentStatusManager.setStatus(stageAgent.id, AgentStatus.Thinking);

let agentResponse = '';
let isFirstChunk = true;

// Rate limiting now handled internally by AgentExecutor
await executor.executeStreaming(
    stageAgent,
    currentStage.agents[0].model,
    conversationContents,
    streamConfig,
    (chunk) => {
        // Set to Speaking on first chunk
        if (isFirstChunk) {
            agentStatusManager.setStatus(stageAgent.id, AgentStatus.Speaking);
            isFirstChunk = false;
        }
        onMessageUpdate(chunk);
        agentResponse += chunk;
    }
);

// AFTER streaming completes (around line 546, after onNewMessage):
agentStatusManager.setStatus(stageAgent.id, AgentStatus.Idle);

// BEFORE (line 554 - in catch block):
} catch (error: any) {
    console.error(`[Agency V2] Stage execution failed:`, error);
    engine.recordFailure(error.message);
    const errorMsg = createSystemMessage(`**❌ Stage Failed**: ${error.message}`, true);
    onNewMessage(errorMsg);
    return { updatedTaskState: engine.getState() };
}

// AFTER:
} catch (error: any) {
    console.error(`[Agency V2] Stage execution failed:`, error);
    agentStatusManager.setStatus(stageAgent.id, AgentStatus.Idle); // Clear status on error
    engine.recordFailure(error.message);
    const errorMsg = createSystemMessage(`**❌ Stage Failed**: ${error.message}`, true);
    onNewMessage(errorMsg);
    return { updatedTaskState: engine.getState() };
}
```

```typescript
// BEFORE (line 638):
const parallelPromises = stageAgents.map(async (agent, index) => {
    const stageAgentDef = currentStage.agents[index];

    // Rate limiting now handled internally by AgentExecutor
    try {
        const result = await executor.executeNonStreaming(
            agent,
            stageAgentDef.model,
            conversationContents,
            agentConfig
        );

        return {
            agent,
            content: result.content,
            model: result.model
        };
    } catch (error: any) {
        console.error(`[Agency V2] Parallel agent ${agent.name} failed:`, error);
        return {
            agent,
            content: `Error: ${error.message}`,
            model: stageAgentDef.model
        };
    }
});

// AFTER:
// Set all parallel agents to Thinking before starting
stageAgents.forEach(agent => {
    agentStatusManager.setStatus(agent.id, AgentStatus.Thinking);
    onAgentChange(agent.id); // Update active agent (will show last one, but status manager tracks all)
});

const parallelPromises = stageAgents.map(async (agent, index) => {
    const stageAgentDef = currentStage.agents[index];

    // Rate limiting now handled internally by AgentExecutor
    try {
        // Set to Speaking when execution starts (non-streaming, so it's quick)
        agentStatusManager.setStatus(agent.id, AgentStatus.Speaking);
        
        const result = await executor.executeNonStreaming(
            agent,
            stageAgentDef.model,
            conversationContents,
            agentConfig
        );

        // Set to Idle when complete
        agentStatusManager.setStatus(agent.id, AgentStatus.Idle);

        return {
            agent,
            content: result.content,
            model: result.model
        };
    } catch (error: any) {
        console.error(`[Agency V2] Parallel agent ${agent.name} failed:`, error);
        agentStatusManager.setStatus(agent.id, AgentStatus.Idle); // Clear on error
        return {
            agent,
            content: `Error: ${error.message}`,
            model: stageAgentDef.model
        };
    }
});
```

```typescript
// BEFORE (line 753):
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// AFTER:
agentStatusManager.clearAll(); // Clear all agent statuses when workflow completes
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// BEFORE (line 761):
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// AFTER:
agentStatusManager.clearAll();
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// BEFORE (line 766):
onAgentChange(null);
return { updatedTaskState: engine.getState() };

// AFTER:
agentStatusManager.clearAll();
onAgentChange(null);
return { updatedTaskState: engine.getState() };
```

```typescript
// When Orchestrator is called (find the orchestrator execution point):
const orchestrator = AGENT_PROFILES.find(a => a.id === 'agent-orchestrator-001');
if (orchestrator) {
    agentStatusManager.setStatus(orchestrator.id, AgentStatus.Thinking);
}

// After orchestrator completes:
if (orchestrator) {
    agentStatusManager.setStatus(orchestrator.id, AgentStatus.Idle);
}
```

---

## Implementation checklist: "Living Team" UX integration

### Phase 1: Foundation files

#### Step 1.1: Create AgentStatusManager service
- [ ] Create `src/services/agentStatusManager.ts`
- [ ] Copy the complete `AgentStatusManager` class code
- [ ] Export singleton `agentStatusManager` instance
- [ ] Verify TypeScript compiles without errors

#### Step 1.2: Create React hooks
- [ ] Create `src/hooks/useAgentStatus.ts`
- [ ] Implement `useAgentStatus(agentId)` hook
- [ ] Implement `useAllAgentStatuses()` hook
- [ ] Verify hooks export correctly

#### Step 1.3: Update AgentStatus enum
- [ ] Open `src/types/agent.ts`
- [ ] Add `Thinking = 'thinking'` to `AgentStatus` enum
- [ ] Add `Speaking = 'speaking'` to `AgentStatus` enum
- [ ] Keep `Idle` and `Active` (backward compatibility)
- [ ] Verify enum exports correctly

### Phase 2: Component updates

#### Step 2.1: Update AgentListItem
- [ ] Open `src/components/AgentListItem.tsx`
- [ ] Import `useAgentStatus` hook
- [ ] Replace static status logic with `useAgentStatus(agent.id)`
- [ ] Add status color mapping (Thinking=blue, Speaking=green, Idle=gray)
- [ ] Add pulsing animation for Thinking/Speaking states
- [ ] Update status text display ("thinking...", "speaking...", "idle")
- [ ] Test component renders without errors

#### Step 2.2: Update AgentList
- [ ] Open `src/components/AgentList.tsx`
- [ ] Update title to "Active Staff Roster" (optional)
- [ ] Verify `AgentListItem` receives correct props
- [ ] Test list renders all agents

#### Step 2.3: Update TypingIndicator
- [ ] Open `src/components/TypingIndicator.tsx`
- [ ] Import `useAgentStatus` hook
- [ ] Use `useAgentStatus` to get real-time status
- [ ] Update status text based on Thinking/Speaking/Idle
- [ ] Add pulsing animation for active states
- [ ] Test typing indicator shows correct status

### Phase 3: Service integration

#### Step 3.1: Add imports to geminiService.ts
- [ ] Open `src/services/geminiService.ts`
- [ ] Add import: `import { agentStatusManager } from './agentStatusManager';`
- [ ] Add import: `import { AgentStatus } from '../types/agent';`
- [ ] Verify imports resolve correctly

#### Step 3.2: Product Planner integration
- [ ] Find line ~369: `onAgentChange(productPlanner.id);`
- [ ] Add: `agentStatusManager.setStatus(productPlanner.id, AgentStatus.Thinking);`
- [ ] Find line ~373: `let plannerResponse = '';`
- [ ] Add: `agentStatusManager.setStatus(productPlanner.id, AgentStatus.Speaking);` (before streaming)
- [ ] Find line ~395: After `onNewMessage(plannerMessage);`
- [ ] Add: `agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);`
- [ ] Find line ~407: `onAgentChange(null);`
- [ ] Add: `agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);` (before onAgentChange)
- [ ] Find line ~414: `onAgentChange(null);` (in catch block)
- [ ] Add: `agentStatusManager.setStatus(productPlanner.id, AgentStatus.Idle);` (before onAgentChange)

#### Step 3.3: Sequential stage execution
- [ ] Find line ~520: `onAgentChange(stageAgent.id);`
- [ ] Add: `agentStatusManager.setStatus(stageAgent.id, AgentStatus.Thinking);`
- [ ] Find line ~522: `let agentResponse = '';`
- [ ] Add: `let isFirstChunk = true;`
- [ ] Find line ~530: Inside `(chunk) => {` callback
- [ ] Add at start of callback:
  ```typescript
  if (isFirstChunk) {
      agentStatusManager.setStatus(stageAgent.id, AgentStatus.Speaking);
      isFirstChunk = false;
  }
  ```
- [ ] Find line ~546: After `onNewMessage(agentMessage);`
- [ ] Add: `agentStatusManager.setStatus(stageAgent.id, AgentStatus.Idle);`
- [ ] Find line ~554: In catch block
- [ ] Add: `agentStatusManager.setStatus(stageAgent.id, AgentStatus.Idle);` (before error handling)

#### Step 3.4: Parallel stage execution
- [ ] Find line ~638: `const parallelPromises = stageAgents.map(...)`
- [ ] Add BEFORE the map:
  ```typescript
  stageAgents.forEach(agent => {
      agentStatusManager.setStatus(agent.id, AgentStatus.Thinking);
      onAgentChange(agent.id);
  });
  ```
- [ ] Find line ~642: Inside `try {` block
- [ ] Add: `agentStatusManager.setStatus(agent.id, AgentStatus.Speaking);` (before executeNonStreaming)
- [ ] Find line ~658: After `result` is returned
- [ ] Add: `agentStatusManager.setStatus(agent.id, AgentStatus.Idle);` (before return)
- [ ] Find line ~664: In catch block
- [ ] Add: `agentStatusManager.setStatus(agent.id, AgentStatus.Idle);` (before error return)

#### Step 3.5: Workflow completion cleanup
- [ ] Find line ~753: `onAgentChange(null);`
- [ ] Add BEFORE: `agentStatusManager.clearAll();`
- [ ] Find line ~761: `onAgentChange(null);`
- [ ] Add BEFORE: `agentStatusManager.clearAll();`
- [ ] Find line ~766: `onAgentChange(null);`
- [ ] Add BEFORE: `agentStatusManager.clearAll();`

### Phase 4: Build and compile

- [ ] Run `npm run build` or `npm run dev`
- [ ] Verify no TypeScript errors
- [ ] Verify no import resolution errors
- [ ] Check console for any runtime errors

### Phase 5: Testing

#### Test 5.1: Basic status display
- [ ] Start the app
- [ ] Open a project
- [ ] Check sidebar shows "Active Staff Roster"
- [ ] Verify all agents show "idle" (gray dot) initially
- [ ] Verify no console errors

#### Test 5.2: Product Planner flow
- [ ] Send a new message to start a workflow
- [ ] Observe Product Planner in sidebar:
  - [ ] Changes to "thinking..." (blue, pulsing) when planning starts
  - [ ] Changes to "speaking..." (green, pulsing) when response streams
  - [ ] Returns to "idle" (gray) when complete
- [ ] Verify TypingIndicator shows correct status text

#### Test 5.3: Sequential stage execution
- [ ] After Product Planner creates a TaskMap
- [ ] Observe next agent (e.g., Builder) in sidebar:
  - [ ] Changes to "thinking..." when stage starts
  - [ ] Changes to "speaking..." when streaming begins
  - [ ] Returns to "idle" when complete
- [ ] Verify only one agent is active at a time (sequential)

#### Test 5.4: Parallel stage execution
- [ ] Trigger a CODE_REVIEW or PLAN_REVIEW stage
- [ ] Observe multiple agents in sidebar:
  - [ ] All review agents show "thinking..." simultaneously
  - [ ] All change to "speaking..." when executing
  - [ ] All return to "idle" when complete
- [ ] Verify multiple agents can be active at once

#### Test 5.5: Error handling
- [ ] Simulate an error (e.g., invalid API key)
- [ ] Verify agent status returns to "idle" on error
- [ ] Verify no status "stuck" in Thinking/Speaking state
- [ ] Check console for error messages (should still work)

#### Test 5.6: Workflow completion
- [ ] Complete a full workflow
- [ ] Verify all agent statuses clear to "idle" when workflow ends
- [ ] Verify no agents remain in Thinking/Speaking state

#### Test 5.7: Visual feedback
- [ ] Verify pulsing animation on Thinking/Speaking states
- [ ] Verify color changes (blue for Thinking, green for Speaking, gray for Idle)
- [ ] Verify status text updates correctly
- [ ] Verify avatar ring animation works (if implemented)

### Phase 6: Edge cases

- [ ] Test rapid message sending (status should update quickly)
- [ ] Test workflow pause/resume (status should persist correctly)
- [ ] Test abort/cancel (status should clear to Idle)
- [ ] Test multiple projects (status should be per-project or global?)
- [ ] Test page refresh (status should reset to Idle)

### Phase 7: Performance

- [ ] Verify no memory leaks (status listeners unsubscribe correctly)
- [ ] Verify no excessive re-renders (React DevTools Profiler)
- [ ] Verify status updates don't block UI (should be instant)

### Phase 8: Documentation

- [ ] Update code comments if needed
- [ ] Document AgentStatusManager usage
- [ ] Note any breaking changes (none expected)

### Phase 9: Final verification

- [ ] All agents show correct status in real-time
- [ ] No console errors or warnings
- [ ] UI feels responsive and "alive"
- [ ] Backend logic unchanged (deterministic workflow still works)
- [ ] Backward compatibility maintained (legacy `activeAgentId` still works)

---

## Quick reference: status lifecycle

```
Idle → Thinking → Speaking → Idle
  ↑                              ↓
  └────────── (on error) ─────────┘
```

## Troubleshooting

If status doesn't update:
1. Check `agentStatusManager` import path
2. Verify `AgentStatus` enum values match
3. Check React hooks are subscribed correctly
4. Verify status updates happen before `onAgentChange` calls

If multiple agents show active incorrectly:
1. Verify `clearAll()` is called on workflow completion
2. Check parallel execution sets status for all agents
3. Verify error handlers clear status

If animations don't work:
1. Check Tailwind classes are correct
2. Verify CSS animations are enabled
3. Check browser DevTools for CSS errors

---
